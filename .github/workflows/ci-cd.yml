name: CI/CD

on:
  push:
  workflow_dispatch:

concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

jobs:
  version:
    runs-on: ubuntu-latest
    outputs:
      semver: ${{ steps.parse.outputs.semver }}
      major: ${{ steps.parse.outputs.major }}
      minor: ${{ steps.parse.outputs.minor }}
      patch: ${{ steps.parse.outputs.patch }}
      exists: ${{ steps.parse.outputs.exists }}
    steps:
      - uses: actions/checkout@v3
      - uses: pkgxdev/dev@v0
      - name: Parse & check version
        id: parse
        run: |
          parse_version_component() {
            component=$(echo "$1" | cut -f"$2" -d.)
            if [ -z "$component" ]; then
              echo "Could not parse version format: $1"
              exit 1
            fi
            echo "$component"
          }
          check_git_tag_exists() {
            git fetch --prune --unshallow --tags
            git show-ref --tags v$1 --quiet && echo "true" || echo "false"
          }
          echo "semver=$VERSION" >> $GITHUB_OUTPUT
          echo "major=$(parse_version_component "$VERSION" 1)" >> $GITHUB_OUTPUT
          echo "minor=$(parse_version_component "$VERSION" 2)" >> $GITHUB_OUTPUT
          echo "patch=$(parse_version_component "$VERSION" 3)" >> $GITHUB_OUTPUT
          echo "exists=$(check_git_tag_exists "$VERSION")" >> $GITHUB_OUTPUT
          echo GitHub Output: $(cat $GITHUB_OUTPUT)

  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: docker/setup-buildx-action@v3
      - uses: docker/metadata-action@v5
        id: meta
        with:
          images: elixir_script:test
      - uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx
          restore-keys: |
            ${{ runner.os }}-buildx-
      - name: Build image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: .github/Dockerfile
          tags: elixir_script:test
          outputs: type=docker,dest=/tmp/elixir_script.tar
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache
          labels: ${{ steps.meta.outputs.labels }}
      - name: Upload image as artifact
        uses: actions/upload-artifact@v3
        with:
          name: elixir_script
          path: /tmp/elixir_script.tar

  e2e-tests:
    needs: [ build ]
    strategy:
      fail-fast: false
      matrix:
        data:
          - name: "return"
            script: |
              "return"
            expected: "return"

          - name: "context"
            script: |
              Map.keys(context)
            expected: "[__struct__,action,actor,api_url,event_name,graphql_url,job,payload,ref,run_id,run_number,server_url,sha,workflow]"
    runs-on: ubuntu-latest
    name: "e2e tests (${{ matrix.data.name }})"
    steps:
      - uses: actions/checkout@v3
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: elixir_script
          path: /tmp
      - name: Load image
        run: docker load --input /tmp/elixir_script.tar
      - name: Update action.yml to point to elixir_script:test
        run: |
          sed -i 's/\(  image: \).*/\1elixir_script:test/' action.yml
      - name: Run gaggle/elixir_script
        id: run
        uses: ./
        with:
          script: |
            ${{ matrix.data.script }}
      - name: Assert output
        run: |
          expected="${{ matrix.data.expected }}"
          output="${{steps.run.outputs.result}}"
          [[ "$output" != "$expected" ]] && echo "::error::❌ Expected '$expected', got '$output'" && exit 1
          echo "✅ Test passed, outputs.result: ${{toJSON(steps.run.outputs.result)}}"

  push:
    runs-on: ubuntu-latest
    needs: [ version, build, e2e-tests ]

    permissions:
      packages: write

    steps:
      - uses: actions/checkout@v3
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}
      - uses: docker/metadata-action@v5
        id: meta
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch,prefix=branch-,enable=${{ github.ref != 'refs/heads/main' }}
            type=semver,pattern=v{{version}},value=${{needs.version.outputs.semver}},enable=${{ github.ref == 'refs/heads/main' && needs.version.outputs.exists == 'false' }}
            type=semver,pattern=v{{major}}.{{minor}},value=${{needs.version.outputs.semver}},enable=${{ github.ref == 'refs/heads/main' && needs.version.outputs.exists == 'false' }}
            type=semver,pattern=v{{major}},value=${{needs.version.outputs.semver}},enable=${{ github.ref == 'refs/heads/main' && needs.version.outputs.exists == 'false' && !startsWith(needs.version.outputs.semver, '0') }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' && needs.version.outputs.exists == 'false' }}
            type=sha,format=long
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: elixir_script
          path: /tmp
      - name: Load image
        run: docker load --input /tmp/elixir_script.tar
      - name: Tag image
        run: |
          echo "${{ steps.meta.outputs.tags }}" | while read -r tag; do
            echo "Processing tag: $tag"
            docker tag elixir_script:test "$tag"
          done
      - name: Push image
        if: ${{ github.ref == 'refs/heads/main' && needs.version.outputs.exists == 'false' }}
        run: docker push --all-tags ghcr.io/gaggle/elixir_script

#!/usr/bin/env -S pkgx +yq bash>=4

set -euo pipefail

show_usage() {
  echo "Usage: releaseit <patch|minor|major>"
  echo ""
  echo "Create a new release by incrementing the version in .pkgx.yaml"
  echo ""
  echo "Arguments:"
  echo "  patch  - Increment patch version (x.y.Z)"
  echo "  minor  - Increment minor version (x.Y.0)"
  echo "  major  - Increment major version (X.0.0)"
}

# Try to fetch tags; if it fails (eg. due to moving tags like v0),
# print helpful instructions and continue using local tags.
fetch_tags_or_report() {
  if git fetch --tags --quiet 2>/dev/null; then
    return 0
  fi

  echo "WARNING: git fetch --tags failed. This can happen if moving tags (eg. v0) differ locally."

  # Detect conflicting tags between remote and local
  declare -A _remote _local

  while read -r sha ref; do
    tag="${ref#refs/tags/}"
    [[ -n "$tag" ]] && _remote["$tag"]="$sha"
  done < <(git ls-remote --tags --refs origin 2>/dev/null || true)

  while read -r sha ref; do
    tag="${ref#refs/tags/}"
    [[ -n "$tag" ]] && _local["$tag"]="$sha"
  done < <(git show-ref --tags 2>/dev/null || true)

  conflicts=()
  for tag in "${!_remote[@]}"; do
    if [[ -n "${_local[$tag]:-}" && "${_local[$tag]}" != "${_remote[$tag]}" ]]; then
      conflicts+=("$tag")
    fi
  done

  if [[ ${#conflicts[@]} -gt 0 ]]; then
    echo "Detected conflicting tags: ${conflicts[*]}"
    echo "To sync, either run:"
    echo "  git fetch --tags --force"
    echo "or update individually, eg:"
    for t in "${conflicts[@]}"; do
      echo "  git tag -d $t && git fetch origin tag $t -f"
    done
  else
    echo "No specific conflicting tags detected. You may try: git fetch --tags --force"
  fi

  # Continue with local tags
  return 0
}

get_last_release() {
  # Get the most recent semver tag (vX.Y.Z), ignore moving tags like v0
  git tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-version:refname | head -1
}

increment_version() {
  local version=$1
  local part=$(echo "$2" | tr '[:lower:]' '[:upper:]')
  IFS='.' read -ra VERSION_PARTS <<< "$version"
  case "$part" in
    MAJOR)
      VERSION_PARTS[0]=$((VERSION_PARTS[0]+1))
      VERSION_PARTS[1]=0
      VERSION_PARTS[2]=0
      ;;
    MINOR)
      VERSION_PARTS[1]=$((VERSION_PARTS[1]+1))
      VERSION_PARTS[2]=0
      ;;
    PATCH)
      VERSION_PARTS[2]=$((VERSION_PARTS[2]+1))
      ;;
    *)
      echo "Error: Invalid version increment part '$2'. Use MAJOR, MINOR, or PATCH." >&2
      exit 1
      ;;
  esac
  echo "${VERSION_PARTS[0]}.${VERSION_PARTS[1]}.${VERSION_PARTS[2]}"
}

# Check if version exists in .pkgx.yaml
current_version=$(yq e '.env.VERSION' .pkgx.yaml 2>/dev/null)
if [ -z "$current_version" ] || [ "$current_version" = "null" ]; then
  echo "ERROR: No env.VERSION found in .pkgx.yaml"
  exit 1
fi

# Fetch latest tags to ensure we have accurate release history (with guidance on failure)
fetch_tags_or_report

# Verify version consistency
last_release=$(get_last_release)
if [ -n "$last_release" ]; then
  # Strip 'v' prefix for comparison
  last_version="${last_release#v}"
  if [ "$current_version" != "$last_version" ] && ! git rev-parse "v$current_version" >/dev/null 2>&1; then
    echo "ERROR: Version mismatch!"
    echo "  .pkgx.yaml version: v$current_version"
    echo "  Last git tag:       $last_release"
    exit 1
  fi
fi

# Handle --help flag
if [ $# -eq 1 ] && [ "$1" = "--help" ]; then
  show_usage
  exit 0
fi

# Show commits if no argument provided
if [ $# -eq 0 ]; then
  echo "Usage: releaseit <patch|minor|major>"
  echo ""

  if git rev-parse "v$current_version" >/dev/null 2>&1; then
    echo "Commits since v$current_version:"
    git log --oneline --pretty=format:"- %s" "v$current_version..HEAD"
  else
    echo "No previous releases, first release?"
    git log --oneline --pretty=format:"- %s" HEAD
  fi
  echo ""
  exit 0
fi

INCREMENT=$1

new_version=$(increment_version "$current_version" "$INCREMENT")

# Show version transition and ask for confirmation
echo "Creating release: v$current_version -> v$new_version"
echo ""
read -p "Continue? [y/N] " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
  echo "Release cancelled."
  exit 0
fi

yq e -i ".env.VERSION = \"$new_version\"" .pkgx.yaml
git add .pkgx.yaml
git commit -m "Release v$new_version"
echo ""
echo "âœ“ Released v$new_version, remember to push the changes"
